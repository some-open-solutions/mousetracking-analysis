<div id="processing_div">
  <input id="submit" type="submit" value="Finish trial" readonly>
  <table>
    <tr>
      <td>
        <div id="canvas"></div>
      </td>
      <td>
        <div id="rotated_canvas"></div>
      </td>
    </tr>
  </table>
  <input type="button" value="Create picture" id="create_picture" onclick="draw_picture()">
  <div id="data_table">
    <table width = "1100">
      <tr>
        <td><p>Mean Y distance </p></td>
        <td><input type="text" name="y_average_dist" id="y_average_dist" readonly></td>
        <td><p>SD for Y distance</p> </td>
        <td><input type="text" name="y_stdev_dist" id="y_stdev_dist" readonly> </td>
      </tr>

      <tr>
        <td><p>Maximum deviation</p></td>
        <td><input type="text" name="Max_dev" id="Max_dev" readonly></td>
        <td><p>RT</p></td>
        <td><input type="text" name="RT" id="RT" readonly></td>
      </tr>
      
      <tr>
      <td><p>AUC above hor line in pixels</p></td>
        <td><input type="text" name="AUC_above" id="AUC_above_val" readonly></td>
      <td><p>AUC below hor line in pixels</p></td>
        <td><input type="text" name="AUC_below" id="AUC_below_val" readonly></td>
      </tr>
      
      <tr>
      <td><p>AUC (Above-Below)</p></td>
        <td><input type="text" name="AUC_diff" id="AUC_diff" readonly></td>
      <td><p>Overall AUC in pixels</p></td>
        <td><input type="text" name="AUC" id="AUC" readonly></td>
      </tr>
      
      <tr>
        <td><p>Raw timestamp array</p></td>
        <td><textarea name="timestamp_textarea" id="timestamp_textarea" readonly></textarea></td>
        <td><p>Full timestamp array</p></td>
        <td><textarea name="every_timestamp_textarea" id="every_timestamp_textarea" readonly></textarea></td>
      </tr>

      <tr>
        <td><p>X-flips</p></td>
        <td><input type="text" name="X_flips" id="X_flips" readonly></td>
        <td><p>Y-flips</p></td>
        <td><input type="text" name="Y_flips" id="Y_flips" readonly></td>
      </tr>

      <tr>
        <td><p>X values</p></td>
        <td><textarea name="x_val_array" id="x_val_array_textarea" readonly></textarea></td>
        <td><p>Y values</p></td>
        <td><textarea name="y_diff_array" id="y_diff_array_textarea" readonly></textarea></td>
      </tr>

      <tr>
        <td><p>X values (1-)</p></td>
        <td><textarea name="x1_val_array" id="x1_val_array_textarea" readonly></textarea></td>
        <td><p>AUC array</p></td>
        <td><textarea name="AUC_array" id="AUC_array_textarea" readonly></textarea></td>
      </tr>
      
      <tr>
        <td><p>Hypotenuse array</p></td>
        <td><textarea name="d_length_array" id="d_length_array_textarea" readonly></textarea></td>
        <td><p>Trajectory length</p></td>
        <td><input type="text" name="Traj_length" id="Traj_length" readonly></td>
      </tr>
    </table>
  </div>
</div>

<script>

function draw_picture(){
  for(i=0;i<(parent.y_array.length-1);i++){    
    canvas.appendChild(createLine(parent.x_array[i], 
                                  parent.y_array[i], 
                                  parent.x_array[i+1], 
                                  parent.y_array[i+1],
                                  "red"));
  }
  for(i=0;i<(parent.y_array.length-1);i++){    
    rotated_canvas.appendChild(createLine(rotated_x[i], 
                                          rotated_y[i],
                                          rotated_x[i+1],
                                          rotated_y[i+1],
                                          "blue"));
  }
  for(i=0;i<(every_x_array.length-1);i++){    
    rotated_canvas.appendChild(createLine(every_x_array[i], 
                                          every_y_array[i], 
                                          every_x_array[i+1], 
                                          every_y_array[i+1],
                                          "yellow"));
  }
}


/* Rotation setup */

function rotate(cx, cy, x, y, angle) { // from theftprevention on http://stackoverflow.com/questions/17410809/how-to-calculate-rotation-in-2d-in-javascript
    var radians = (Math.PI / 180) * angle,
        cos = Math.cos(radians),
        sin = Math.sin(radians),
        nx = (cos * (x - cx)) + (sin * (y - cy)) + cx,
        ny = (cos * (y - cy)) - (sin * (x - cx)) + cy;
    return [nx, ny];
}

/* Calculate general line characteristics */

function calculate_mean(input_array){
  var sum = 0;
  array_length = input_array.filter(Number).length;
  
  for( var i = 0; i < input_array.length; i++ ){
    if(!isNaN(parseInt(input_array[i]))){
      sum += parseInt( input_array[i], 10 ); //don't forget to add the base
    }
  }
  return sum/array_length;
}

function calculate_sd(input_array){
  var sd = 0;
  array_length = input_array.filter(Number).length;
      
  for( var i = 0; i < input_array.length; i++ ){
    if(!isNaN(parseInt(input_array[i]))){
      sd += Math.pow((Math.abs(parseInt( input_array[i], 10 ) - calculate_mean(input_array))),2); //don't forget to add the base
    }
  }
  return Math.sqrt(sd/(array_length-1));
}


function createLineElement(x, y, length, angle, this_colour) {
    var line = document.createElement("div");
    var styles = 'border: 1px solid '+ this_colour +'; '
               + 'width: ' + length + 'px; '
               + 'height: 0px; '
               + '-moz-transform: rotate(' + angle + 'rad); '
               + '-webkit-transform: rotate(' + angle + 'rad); '
               + '-o-transform: rotate(' + angle + 'rad); '  
               + '-ms-transform: rotate(' + angle + 'rad); '  
               + 'position: absolute; '
               + 'top: ' + y + 'px; '
               + 'left: ' + x + 'px; ';
    line.setAttribute('style', styles);  
    return line;
}

function createLine(x1, y1, x2, y2, this_color) {
    var a = x1 - x2,
        b = y1 - y2,
        c = Math.sqrt(a * a + b * b);

    var sx = (x1 + x2) / 2,
        sy = (y1 + y2) / 2;

    var x = sx - c / 2,
        y = sy;

    var alpha = Math.PI - Math.atan2(-b, a);
    //var this_color = "blue";

    return createLineElement(x, y, c, alpha, this_color);
}


if(typeof(parent.uber_data) == "undefined"){
    //create it
    parent.uber_data = {
        accuracy : [],
        mean_y: [],
		std_y: [],
        max_dev: [],
		RT: [],
		AUC_total: [],
		AUC_diff: [],
		AUC_above: [],
		AUC_below: [],
		x_flips: [],
		y_flips: [],
		x_arrays: [],
        y_arrays: [],
		timestamps: [],
		traj_length: [],
        condition: [],
        shuffle_type: [],
    }
}



/* Create raw trajectory */


/* --- Trajectory and data processing per trial --- */

function process_trial_function(error_message){
    
    $("#error_message").val(error_message);
    

/* Trajectory start and end */

    start_x = parseFloat($(".start_tracking").css("left").replace("px","")) + parseFloat($(".start_tracking").css("width").replace("px",""))/2; //viewportWidth/2; //parent.x_array[0];
    start_y = parseFloat($(".start_tracking").css("top").replace("px","")) + parseFloat($(".start_tracking").css("height").replace("px",""))/2; //viewportWidth/2; //parent.x_array[0];
    

    // end_x and end_y depend on the trial type (whether it ends on the left or right)
    if(CorrectSide == "Left"){
        
        // bottomleft  y = co-ordinates - height
        
        end_x   =  parseFloat($("#resp_left").css("left").replace("px",""));  // parent.x_array[parent.x_array.length-1];
        end_y   =  parseFloat($("#resp_left").css("top").replace("px","")) + parseFloat($("#resp_left").css("height").replace("px",""));  // parent.x_array[parent.x_array.length-1];
        

    } else { // assume it is right

        //bottomRight y = co-ordinates -height
        //bottomRight x = co-ordinates + width
        
        end_x   =  parseFloat($("#resp_right").css("left").replace("px","")) + parseFloat($("#resp_left").css("width").replace("px",""));  // parent.x_array[parent.x_array.length-1];
        end_y   =  parseFloat($("#resp_right").css("top").replace("px","")) + parseFloat($("#resp_left").css("height").replace("px",""));  // parent.x_array[parent.x_array.length-1];

    }
    
/* Line properties */
	
    //y = mx+c
    m       = (start_y - end_y)/(end_x-start_x);
    c       = start_y - m*start_x;
    
    auc_object = {
      calculate_x_gap: function(y_value, x_value){
        // y = mx +c
        // x = (y-c)/m
        quickest_x = (y_value-c)/m;
        return (quickest_x-x_value);
      }
    }
    x_gap_array = [];
    y_gap_array = [];
    
/* Trajectory rotation */
	
    // rotate here
    var deltaX = end_x - start_x;
    var deltaY = start_y - end_y;
    var rad = Math.atan2(deltaY, deltaX); // In radians
    var deg = rad * (180 / Math.PI);
    
    [rot_end_x,rot_end_y] = rotate(start_x,start_y,end_x,end_y,-deg);
    rotated_x = [];
    rotated_y = [];
    
    if(typeof(parent.x_array) !== "undefined"){
        for(i=0;i<parent.x_array.length;i++){
          
          [new_x_val,new_y_val] = rotate(start_x,start_y,parent.x_array[i],parent.y_array[i],-deg);
          rotated_x.push(new_x_val);
          rotated_y.push(new_y_val);
        }
        
        parent.x_line_start = start_x;
    	parent.x_line_end = rot_end_x;
    	parent.y_line_start = start_y;
    	parent.y_line_end = rot_end_y;
        
        canvas.appendChild(createLine(start_x, start_y, end_x, end_y,"black"));
        rotated_canvas.appendChild(createLine(start_x, start_y, rot_end_x, rot_end_y,"black"));
        
        // process rotated data - identify y-values that are equidistant on the x-axis //
        
        // use rounded up values
        for(i=0;i<rotated_x.length;i++){
          rotated_x[i]=Math.ceil(rotated_x[i]);
          rotated_y[i]=Math.ceil(rotated_y[i]);
        }
    	
        /* Filling of gaps by interpolation */
         	
        every_y_array=[];
        every_x_array=[];
        every_timestamp_array=[];
        
        for(i=0;i<rotated_x.length-1;i++){
          var x_gap_size= rotated_x[i+1]-rotated_x[i];
          every_y_array.push(rotated_y[i]);
          every_x_array.push(rotated_x[i]);
          every_timestamp_array.push(parent.timestamp_array[i]);
        
          if(x_gap_size > 1){
            for(j=0;j<x_gap_size-1;j++){
              new_x_value = rotated_x[i]+1+j;
              new_y_value = rotated_y[i]+(1+j)*(rotated_y[i+1]-rotated_y[i])/x_gap_size;
        	  new_time_value = parent.timestamp_array[i]+(1+j)*(parent.timestamp_array[i+1] - parent.timestamp_array[i])/x_gap_size;
              every_x_array.push(new_x_value);
              every_y_array.push(new_y_value);
        	  every_timestamp_array.push(new_time_value);
            }
          }
          
        	else if(x_gap_size < -1){
        		var inverted_gap_size = x_gap_size*(-1);
        		for(j=0;j<inverted_gap_size-1;j++){
        			new_x_value = rotated_x[i]-1-j;
        			new_y_value = rotated_y[i]-(1+j)*(rotated_y[i+1]-rotated_y[i])/x_gap_size;
        			new_time_value = parent.timestamp_array[i]+(1+j)*(parent.timestamp_array[i+1] - parent.timestamp_array[i])/inverted_gap_size;
        			every_x_array.push(new_x_value);
        			every_y_array.push(new_y_value);
        			every_timestamp_array.push(new_time_value);
        		}
        	}
        } 
    
        // Add last value of rotated_x and rotated_y to every_x_array and every_y_array, respectively, as these values were not included in the iterations above
        every_x_array.push(rotated_x[rotated_x.length-1]);
        every_y_array.push(rotated_y[rotated_y.length-1]);
        every_timestamp_array.push(parent.timestamp_array[parent.timestamp_array.length-1]);
        
        /* Get reaction time */
            
        // X, Y & T arrays; RT (corrected for the fact that timepoint 1 in timestamp_array has a value of 1 instead of 0)
        // But not sure if this offset of 1 ms is also reflected in final timepoint
        ReactionTime = parent.timestamp_array[parent.timestamp_array.length-1];
        console.dir(ReactionTime);
        $("#RT").val(ReactionTime);
        
    	/* Average Y distance calculation */
    	
        var y_sum = 0;
        for( var i = 0; i < every_y_array.length; i++ ){
            y_sum += every_y_array[i];
        }
        
        // y_avg is now calculated with difference between horizontal line and recorded Y value
        // instead of with absolute y values only
        
        var y_avg = rot_end_y - (y_sum/every_y_array.length);
        $("#y_average_dist").val(y_avg);
        
        
        // calculate standard deviation 
        y_stdev = calculate_sd(every_y_array);
        
        $("#y_stdev_dist").val(y_stdev);
        
        for(i=end_y;i<start_y;i++){
          y_gap_array[i-end_y]=i;
        }
        for(i=end_y;i<start_y;i++){
          y_gap_array[i-end_y]=i;
        }
        
        // add coloring in to convey time
        
        // based on Madox on http://stackoverflow.com/questions/4270485/drawing-lines-on-html-page
        
        
    /* calculate maximum deviation from curve */
        //Max_dev is the highest value (e.g. would pick 20 instead of -100)
        //Max_dev is the highest deviation from 0 and can be either positive or negative
        
        var y_diff = [];
        for(var i=0; i<every_y_array.length; i++) {
        	y_diff.push(rot_end_y - every_y_array[i]);
        }
        
        var diff_max = Math.max.apply(Math,y_diff);
        var diff_min = Math.min.apply(Math,y_diff);
        
        var abs_diff_max = Math.abs(diff_max);
        var abs_diff_min = Math.abs(diff_min);
        
        var Max_dev = [];
        
        if ((abs_diff_max - abs_diff_min) > 0){
            Max_dev.push(diff_max);
        }
        else if ((abs_diff_max - abs_diff_min) < 0) {
        	Max_dev.push(diff_min);
        }
        else if ((abs_diff_max - abs_diff_min) == 0) {
        	Max_dev.push(0);
        }
        
        
     /* Calculate number of X flips and Y flips, based on original, non-rotated trajectory */
        
        // Currently, also a 'jitter count' is kept. This saves how many times a flip occurs for just one value (e.g. x_direction_memory: 1,1,1,1,1,-1,1,1,1)
        //   This is most probably an artefact, caused by 1. miniscule hand movement 2. rough surface
        //   3. most likely: issue with updating of picture when trajectory crosses the 600 px line.
        // 	 'filtered_x_flips' and 'filtered_y_flips' solve this issue, but are currently not displayed in the post-trial response boxes.
        //   Another possible issue: length of arrays and delta_arrays not the same. But this could be because delta_arrays probably begins at the first actual change.
        
        x_flips = 0;
        filtered_x_flips = 0;
        x_delta_array = [];
        x_direction_memory = [];
        x_jitter_count = 0;
        y_flips = 0;
        filtered_y_flips = 0;
        y_delta_array = [];
        y_direction_memory = [];
        y_jitter_count = 0;
        
        for (var i=1; i<parent.x_array.length; i++)  {
        x_delta_array.push(parent.x_array[i] - parent.x_array[i-1]);}		
        
        for (var i=0; i<x_delta_array.length; i++)   {
        	if (x_delta_array[i] == 0) {
        		x_direction_memory.push(x_direction_memory[i-1]);}
        	else if (x_delta_array[i] > 0) {
        		x_direction_memory.push(1);}
        	else if (x_delta_array[i] < 0)  {
        		x_direction_memory.push(-1);}
        	}
        
        for (var i=1; i<x_direction_memory.length; i++)   {
        	if ((x_direction_memory[i] * x_direction_memory[i-1]) == -1) {
        		x_flips += 1;}
        	if ((x_direction_memory[i] != x_direction_memory[i-1]) && (x_direction_memory[i] != x_direction_memory[i+1]))
        		{x_jitter_count += 1;}
        	} 
        
        if (x_jitter_count > 0) {
        filtered_x_flips = x_flips - (2*x_jitter_count);}
        
        
        for (var i=1; i<parent.y_array.length; i++)  {
        y_delta_array.push(parent.y_array[i] - parent.y_array[i-1]);}		
        
         for (var i=0; i<y_delta_array.length; i++)   {
        	if (y_delta_array[i] == 0) {
        		y_direction_memory.push(y_direction_memory[i-1]);}
        	else if (y_delta_array[i] > 0) {
        		y_direction_memory.push(1);}
        	else if (y_delta_array[i] < 0)  {
        		y_direction_memory.push(-1);}	
         }
        
          for (var i=1; i<y_direction_memory.length; i++)   {
        		if (((y_direction_memory[i] * y_direction_memory[i-1]) == -1) && (y_direction_memory[i-1] != y_direction_memory[i+1])) {
        		y_flips += 1;}
        		if ((y_direction_memory[i] != y_direction_memory[i-1]) && (y_direction_memory[i] != y_direction_memory[i+1]))
        		{y_jitter_count += 1;}
        	} 
        	
        if (y_jitter_count > 0) {
            filtered_y_flips = y_flips - (2*y_jitter_count);
        }
    	
    
        $("#X_flips").val(x_flips);
        // Keep in mind that this includes jitter.
        // Also, x_flips and y_flips are calculated based on the rotated trajectory.
        // An 'ideal' curve in a False_participant trial would show 1 x_flip in the original trajectory, but 0 x_flips in the rotated trajectory.
        $("#Y_flips").val(y_flips);
        
    /* Array storage */
    
        // Store x, y and timestamp values as response
        $("#y_diff_array_textarea").val(y_diff);
        $("#x_val_array_textarea").val(every_x_array);
        $("#timestamp_textarea").val(parent.timestamp_array);
    	$("#every_timestamp_textarea").val(every_timestamp_array);
        
        // X-array corrected for its starting position, i.e. all values reduced by x[0]
        
        x1_val_array = [];
        for (i=0;i<every_x_array.length;i++){
        	x1_val_array[i] = every_x_array[i]-every_x_array[0]+1
        }
        $("#x1_val_array_textarea").val(x1_val_array);
       
    
     /* Trajectory length */
     
        // Calculate length of trajectory, by using Pythagorean theorem
         // Note: the minus in these for-loops is justified, as calculation of dx and dy should stop at the penultimate value
         // Due to zero-based indexing, last iteration should work with i = length-2 and i = length-1
        
        every_x_delta_array = [];
        every_y_delta_array = [];
        
        for (var i=0;i<every_x_array.length-1;i++){
        	every_x_delta_array[i] = every_x_array[i+1] - every_x_array[i]
        }
        
        for (var i=0;i<every_y_array.length-1;i++){
        	every_y_delta_array[i] = every_y_array[i+1] - every_y_array[i]
        }
        
         // Array with length of hypotenuses: for every increase in x, get the difference in y and calculate the length of the hypotenuse
        Pyt_array = [];
        
        for (var i=0;i<every_x_delta_array.length;i++){
        	dx = every_x_delta_array[i];
        	dy = every_y_delta_array[i];
        	squared_dx = Math.pow(dx,2);
        	squared_dy = Math.pow(dy,2);
        	squared_hyp = squared_dx + squared_dy;
        	hypotenuse = Math.sqrt(squared_hyp);
        	Pyt_array[i] = hypotenuse;
        }
        	
        
        $("#d_length_array_textarea").val(Pyt_array);
        
        Traj_length_val = 0;
        
        for (i=0;i<Pyt_array.length;i++){
        	Traj_length_val += Pyt_array[i];
        }
        
        $("#Traj_length").val(Traj_length_val);
        
     /* AUC calculation */
     
        var area = [];
        var AUC_above = 0;
        var AUC_below = 0;
        
        for (i=0;i<every_x_array.length-1;i++){
        	
        	if (every_x_array[i+1] == every_x_array[i]){
        		area[i] = 0; 
        	}
        	else if (every_x_array[i+1] != every_x_array[i]){
        		area[i] = (y_diff[i+1] + y_diff[i])/2;
        		
        		if (area[i] > 0){
        			AUC_above += area[i];
        		}
        		else if (area[i] < 0){
        			AUC_below += area[i];
        	    }
            }
        }
    	
    	// Store AUC_above and AUV_below correctly based on target position
    	 if( CorrectSide == "Left"){
            real_AUC_above = AUC_below;
            real_AUC_below = AUC_above;
    		
    		AUC_above = real_AUC_above * -1;
    		
    		if (AUC_above != 0){
    		AUC_above *-1;}
    		
    		AUC_below = real_AUC_below * -1;
    		if (AUC_below != 0){
    		AUC_below *-1;}
        }
        
        // This part is needed to summate AUC_above and AUC_below (makes AUC_below positive)
        var rectified_below = AUC_below * -1;
        var total_AUC = AUC_above + rectified_below;
        
        var area_sum = 0;
        for (var i=0;i<area.length;i++){
        	area_sum += area[i];
        }
        
    	if( CorrectSide == "Left"){
    	area_sum = area_sum * -1;}
    	
        $("#AUC_array_textarea").val(area);
        $("#AUC_diff").val(area_sum);
        $("#AUC").val(total_AUC);
        $("#AUC_above_val").val(AUC_above);
        $("#AUC_below_val").val(AUC_below);
        
        $("#Max_dev").val(Max_dev);
        
    /* store data for final processing */
        
    	trial_data = {},
    
        parent.uber_data.x_arrays.push(every_x_array);
        trial_data.x_arrays = [every_x_array];
        
        if( CorrectSide == "Left"){
            var y_array = y_diff.map(function(x){ return x*-1 });
            parent.uber_data.y_arrays.push(y_array);
            trial_data.y_arrays  =[y_array];
        } else {
            parent.uber_data.y_arrays.push(y_diff);
            trial_data.y_arrays  = [y_diff];
        }
        
      parent.uber_data.mean_y.push(y_avg);
    	parent.uber_data.std_y.push(y_stdev);
    	parent.uber_data.max_dev.push(Max_dev);
    	parent.uber_data.RT.push(ReactionTime);
    	parent.uber_data.AUC_total.push(total_AUC);
    	parent.uber_data.AUC_diff.push(area_sum);
    	parent.uber_data.AUC_above.push(AUC_above);
    	parent.uber_data.AUC_below.push(AUC_below);
    	parent.uber_data.x_flips.push(x_flips);
    	parent.uber_data.y_flips.push(y_flips);
    	parent.uber_data.condition.push(this_condition);
      parent.uber_data.timestamps.push(every_timestamp_array);  
    	parent.uber_data.traj_length.push(Traj_length_val);
    	console.dir(parent.uber_data);
    	parent.uber_data.shuffle_type.push(shuffle_type);
    
    	// save trial by trial
    	trial_data.mean_y=[y_avg];
    	trial_data.std_y=[y_stdev];
    	trial_data.max_dev=[Max_dev];
    	trial_data.RT=[ReactionTime];
    	trial_data.AUC_total=[total_AUC];
    	trial_data.AUC_diff=[area_sum];
    	trial_data.AUC_above=[AUC_above];
    	trial_data.AUC_below=[AUC_below];
    	trial_data.x_flips=[x_flips];
    	trial_data.y_flips=[y_flips];
    	trial_data.condition=[this_condition];
      trial_data.timestamps=[every_timestamp_array];  
    	trial_data.traj_length=[Traj_length_val];
    	trial_data.shuffle_type=[shuffle_type];
    	
    	
    	if(typeof(parent.User_Data) == "undefined" | parent.User_Data.Username == "Admin:Simulator"){
        var this_username = "simulator";
        var experiment_name = "simulator_blah";
      } else {
        var this_username   = parent.User_Data.Username;
        var experiment_name = parent.User_Data.Exp_Name;
      }
        
      // need to add experiment name
      var trial_no = parent.Collector_Experiment.data.globals.position;
      //var trial_no = parent.uber_data.mean_y.length; //arbitrary which variable from parent.uber_data is used
      
      ajax_json_read_write(experiment_name+"_"+this_username+"_"+"TrialNo_"+trial_no+".json",JSON.stringify(trial_data),"Write","json");
    }
}
</script>